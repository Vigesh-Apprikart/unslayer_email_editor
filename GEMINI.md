# Project Overview

This is a React-based web application that integrates the Unlayer email editor. The application provides a user interface for designing emails and then viewing the generated JSON, HTML, and plain text output. It uses Vite for the build tooling, and the UI is styled with Tailwind CSS.

The core of the application is the `EmailEditorWithTabs` component, which manages the email editor, tab switching, and the generation of different output formats.

## Features

- **Design Data Validation on Save:** Before processing and saving a design, the application now performs an explicit validation step. It checks if the design data extracted from the Unlayer editor is valid and not empty. If the design is found to be invalid or empty, the save operation is aborted, preventing the storage of incomplete or erroneous data.
  - **Manual Load:** A "Load Design" button is now available. Clicking this button will attempt to load a previously saved design from `localStorage`. If no design is found, or if the saved design is corrupted, the editor will be cleared, and an empty design will be loaded, providing a fresh canvas. This ensures users can explicitly manage their loaded designs.
  - **Saving Designs (Auto & Manual):**
    - **Auto-Save:** Your work is automatically saved in the background shortly after you stop making changes. This is triggered by listening to the editor's `design:updated` event, which exports the current design data.
    - **Manual Save:** A "Save Design" button is available for you to save your work at any time, immediately triggering an export.
    - **Data Formats:** On every save (manual or auto), the design is exported using `unlayer.exportHtml()`. This process yields:
      - **JSON Format (`data.design`):** The editable JSON structure of the email, explicitly defining all components (e.g., text blocks, image blocks, buttons, rows, columns) and their properties. This format is ideal for database storage and loading back into the editor for further modifications. This JSON is also preserved in `localStorage`.
      - **HTML Format (`customHtml`):** A robust, "bulletproof" email-safe HTML is generated from the design's JSON, directly representing the rendered output of all design components. This HTML is designed for final rendering (e.g., in email clients or external applications) and is available via the HTML tab or the `onHtmlExport` prop.
      - **Plain Text Format (`plainText`):** A plain text version of the email is generated by processing the application's custom-generated HTML. This output strictly includes only the visible text content extracted from the design components, ensuring an accurate and clean fallback for email clients that do not render HTML.
    - **Tab Content Synchronization:** When the "Save Design" button is triggered (either manually or via auto-save), the application performs a comprehensive synchronization process. First, it extracts the current email design data from the Unlayer editor. This data then undergoes a validation step to ensure its integrity. Upon successful validation, the extracted design data is used to:
      1.  Automatically update the **JSON tab** with the design's raw JSON structure.
      2.  Automatically update the **HTML tab** with the rendered, "bulletproof" HTML output.
      3.  Automatically update the **Plain Text tab** with a clean, text-only version of the email content.
          This meticulous process ensures seamless data consistency, allowing users to view their email design accurately in multiple formats immediately after saving.
- **Undo/Redo Functionality:**
  - Users can easily undo and redo actions within the editor using dedicated "Undo" and "Redo" icons, powered by the `lucide-react` library (specifically `RotateCcw` for undo and `RotateCw` for redo).
  - These icons are dynamically enabled or disabled based on the availability of actions to undo or redo.
  - The Undo/Redo feature is enabled by default and configured with `autoSelect: true` and `autoFocus: true` for an enhanced user experience, allowing for flexible content creation without fear of permanent mistakes.
- **Preview Designs:**
  - Users can preview their email designs in different device modes (desktop, tablet, and mobile) to ensure responsiveness and compatibility across various devices.
  - The programmatic control buttons to show desktop, mobile, or hide the preview are no longer directly exposed in the UI, but the underlying functionality remains.
  - Custom device resolutions are configured to test designs at specific viewport sizes, enhancing the accuracy of responsive testing.
- **Responsive Controls:**
  - The editor's default responsive behavior has been customized for improved mobile layout control.
  * "Do Not Stack on Mobile" for rows is set to `true` by default, ensuring columns do not stack vertically on smaller screens.
  * "Hide on Mobile" for button elements is set to `true` by default, making buttons hidden on mobile devices.
  - These customizations provide more consistent responsive design behavior and cater to specific mobile layout requirements.
- **Auto-Select on Drop:** The Unlayer editor is configured to automatically select a design tool and display its properties panel immediately after it is dragged and dropped onto the canvas. This enhances the user experience by eliminating the need for an additional click to select newly added elements.
- **Custom Font Support:** The editor now supports custom fonts, allowing users to select branded or specialized fonts. This is configured by providing a `fonts` object during initialization, which includes `customFonts` (with labels, CSS font stacks, and optional Google Fonts URLs) and the option to `showDefaultFonts`. Proper CSS font stacks with fallbacks ensure reliable rendering across various email clients.
- **Merge Tags for Personalization:** Merge tags functionality has been integrated, enabling users to add personalized placeholders (e.g., `{{first_name}}`, `{{last_name}}`) to email templates. These tags are configurable with `name`, `value`, and `sample` attributes, and can be organized into logical groups for easy selection. This allows for dynamic content replacement at send time.
- **Device Management:** The editor's device management has been configured to provide granular control over the design environment. Both `desktop` and `mobile` devices are explicitly enabled for designing, with `desktop` set as the default viewing mode on initialization. This allows users to create responsive content and provides flexibility in controlling the design context.
  - **Manual Device Switching:**
    - The editor now features manual "Desktop" and "Mobile" view toggle buttons in the custom header (using `Monitor` and `Smartphone` icons from `lucide-react`).
    - **Root Cause & Solution:** The standard Unlayer `deviceSwitcher: true` appearance setting only functions when the default Unlayer toolbar is rendered. Since this application uses a fully custom toolbar, the default switcher never appears. Switching is now handled programmatically using the `unlayer.setDevice()` API.
    - This allows users to test responsive designs directly within the custom interface, with the active device being visually highlighted in the toolbar.
- **Enhanced Editor UI:**
  - The email editor's height has been increased to provide more vertical space, creating a more comfortable and spacious design environment. The editor's container now dynamically fills the available vertical space, and the editor component itself is configured to stretch to 100% of its container's height.
  - The "Undo," "Redo," "Load Design," and "Save Design" buttons are now located in the main header, next to the view tabs (Design, JSON, etc.). This provides consistent access to these actions, which are enabled only when the "Design" tab is active.
- **Customizable Body Defaults:**
  - The editor's body options are configured with specific default values for text color (`#000000`), background color (`#FFFFFF`), font family (`'Open Sans',sans-serif`), content alignment (`center`), and font weight (`700`).
  - Additionally, the `preheaderText` is set to `'Hello World'` through `defaultValue` in the `unlayer.init()` configuration, and the `contentWidth` is programmatically set to `'700px'` using `unlayer.setBodyValues()` after the editor loads.
  - These customizations ensure a consistent visual starting point for new email designs, aligning with branding guidelines or application requirements.

## Built-In Property Editors Integration

The Unlayer email editor provides a rich set of built-in property editors that allow for extensive customization of email elements directly within the editor interface. These editors can be configured within the `options.tools.properties` object for each tool, enabling specific input types, default values, and data validation. Below are examples of how various property editors have been integrated into the `EmailEditorWithTabs` component, demonstrating their usage and configuration.

### Configuration Structure

Property editors are configured by adding an object for each property under a tool's `properties` key. Each property object typically defines a `label`, `defaultValue`, and `widget` type, along with any widget-specific `data` or editor options.

```javascript
                            tools: {
                                html: { /* ... */ },
                                bodies: {
                                    properties: {
                                        // Example Property Editor Integrations
                                        subject: { /* ... */ },       // Text Input
                                        borderColor: { /* ... */ },  // Color Picker
                                        enableShadow: { /* ... */ }, // Toggle
                                        theme: { /* ... */ },        // Dropdown
                                        // Existing body properties...
                                    },
                                },
                                rows: {
                                    properties: {
                                        // Example Property Editor Integration
                                        rowSpacing: { /* ... */ },   // Counter
                                        // Existing row properties...
                                    },
                                },
                                button: {
                                    properties: {
                                        // Example Property Editor Integration
                                        buttonLink: { /* ... */ },   // Link
                                        // Existing button properties...
                                    },
                                },
                            },
```

### Examples of Integrated Property Editors

Here's a breakdown of the property editors integrated as examples:

#### 1. Text Input (`widget: 'text'`)

- **Purpose:** Allows users to input single-line text strings. Ideal for titles, labels, or short descriptions.
- **Integration (for `bodies` tool):**

  ```javascript
  subject: {
      label: 'Email Subject',
      defaultValue: 'New Email Design',
      widget: 'text',
  },
  ```

  - **Description:** A custom property `subject` has been added to the `bodies` tool. Users can input the email subject, which defaults to "New Email Design".

#### 2. Color Picker (`widget: 'color_picker'`)

- **Purpose:** Provides an intuitive interface for users to select colors, with support for HEX, RGB, and RGBA formats.
- **Integration (for `bodies` tool):**

  ```javascript
  borderColor: {
      label: 'Body Border Color',
      defaultValue: '#CCCCCC',
      widget: 'color_picker',
  },
  ```

  - **Description:** A custom `borderColor` property has been added to the `bodies` tool, allowing users to select a border color for the email body with a default of light grey (`#CCCCCC`).

#### 3. Toggle (`widget: 'toggle'`)

- **Purpose:** Presents a simple on/off switch for boolean properties.
- \*\*Integration (for `bodies` tool):</h4

  ```javascript
  enableShadow: {
      label: 'Enable Body Shadow',
      defaultValue: false,
      widget: 'toggle',
  },
  ```

  - **Description:** A `enableShadow` property is added to the `bodies` tool, providing a toggle switch to enable or disable a body shadow, defaulting to `false`.

#### 4. Dropdown (`widget: 'dropdown'`)

- **Purpose:** Enables users to select a value from a predefined list of options. Requires a `data` array of `{ label, value }` pairs.
- **Integration (for `bodies` tool):**

  ```javascript
  theme: {
      label: 'Email Theme',
      defaultValue: 'light',
      widget: 'dropdown',
      data: [
          { label: 'Light', value: 'light' },
          { label: 'Dark', value: 'dark' },
          { label: 'Blue', value: 'blue' },
      ],
  },
  ```

  - **Description:** A `theme` dropdown is added to the `bodies` tool, allowing users to choose from "Light", "Dark", or "Blue" themes, with "light" as the default.

#### 5. Counter (`widget: 'counter'`)

- **Purpose:** Provides a numeric input with increment/decrement buttons, useful for properties like padding, margin, or font sizes. Can be configured with `min`, `max`, and `step` values.
- **Integration (for `rows` tool):**

  ```javascript
  rowSpacing: {
      label: 'Row Spacing (px)',
      defaultValue: 10,
      widget: 'counter',
      data: {
          min: 0,
          max: 50,
          step: 5,
      },
  },
  ```

  - **Description:** A `rowSpacing` property is added to the `rows` tool, letting users set the vertical spacing between rows using a counter that ranges from 0 to 50 pixels, incrementing by 5.

#### 6. Link (`widget: 'link'`)

- **Purpose:** Facilitates the input of URLs, including options for target (e.g., `_blank`).
- **Integration (for `button` tool):**

  ```javascript
  buttonLink: {
      label: 'Button URL',
      defaultValue: {
          url: 'https://example.com',
          target: '_blank',
      },
      widget: 'link',
  },
  ```

  - **Description:** A `buttonLink` property is added to the `button` tool, allowing users to specify the URL and target for a button, defaulting to `https://example.com` opening in a new tab.

* **Advanced Data Generation:**
  - **JSON:** A clean JSON representation of the email design is generated on every save.
  - **HTML:** A robust, "bulletproof" email-safe HTML is generated from the design. The generation logic follows industry best practices to ensure maximum compatibility across a wide range of email clients. This includes using pure table-based layouts for all structural elements, implementing fixes for common Gmail image rendering issues, and using fluid-width containers for modern responsive design. The HTML output is formatted by default for better readability.
  - **Plain Text:** A plain text version of the email is generated by processing the application's custom-generated HTML. This ensures that headings, paragraphs, and other text content are correctly extracted and formatted, providing a comprehensive fallback for email clients that do not render HTML.

### Integrating Exported HTML

When using the HTML code generated by the editor (accessible via the HTML tab or the `onHtmlExport` prop), it is crucial to understand that it represents a full, self-contained HTML document. Directly injecting this full document into a `div` using `dangerouslySetInnerHTML` in a React application is generally not recommended, as browsers will often ignore `<head>` content (where critical CSS is defined) when inserted into an existing `<body>`.

To ensure proper rendering of the email design (including all styles, images, and layout) outside the editor, it is highly recommended to render the HTML within an `<iframe>`. The `EmailEditorWithTabs` component now exposes an `onHtmlExport` prop, which is a callback function that provides the generated "bulletproof" HTML string whenever the design is saved or updated.

A dedicated `EmailPreviewIframe.jsx` component has been created in `src/components/EmailPreviewIframe.jsx` to facilitate this. This component takes the generated `htmlContent` as a prop and renders it within an `<iframe>`, providing its own isolated document context where the email HTML can be fully and correctly interpreted by the browser.

Usage Example:

```jsx
// In your parent component (e.g., EditorPage.jsx)
import React, { useState } from "react";
import EmailEditorWithTabs from "./EmailEditorWithTabs";
import EmailPreviewIframe from "./EmailPreviewIframe";

const EditorPage = () => {
  const [exportedHtml, setExportedHtml] = useState("");

  const handleHtmlExport = (html) => {
    setExportedHtml(html);
  };

  return (
    <div>
      {/* Your Email Editor */}
      <EmailEditorWithTabs onHtmlExport={handleHtmlExport} />

      {/* Display the exported HTML */}
      {exportedHtml && (
        <>
          <h2>Rendered Email Preview:</h2>
          <EmailPreviewIframe htmlContent={exportedHtml} />
        </>
      )}
    </div>
  );
};
```

- **Copy to Clipboard:** Each of the JSON, HTML, and Plain Text tabs has a "Copy" button that allows you to easily copy the content of that tab to your clipboard.

### Bug Fixes

- **Save Stuck After Adding Image:** Fixed a critical bug where the "Save Design" functionality would get stuck in a loading state after an image was added to the editor. This was caused by `generateHtmlFromDesign` attempting to use undefined `width` or `height` properties from the Unlayer design JSON when creating the `<img>` tag, resulting in invalid HTML (`width="undefined"`). The fix now includes robust checks for image dimensions, providing sensible default fallbacks (e.g., `width=600`, `height=auto`) if the Unlayer design data doesn't explicitly provide them, ensuring valid HTML is always generated and the save process completes successfully.
- **Editor Canvas Unusable (Red Screen):** Fixed a critical bug where the editor's design canvas would render with a red background and red text, making it unusable. The initial fix corrected the default color values in the Unlayer configuration (changed `textColor` to black (`#000000`) and `backgroundColor` to white (`#FFFFFF`)). This has been further improved by adding logic to `useEffect` that detects if a previously saved design in `localStorage` still contains these old red color values. If such a design is found, it is now automatically cleared from `localStorage` to ensure the editor always starts with a clean slate, applying the correct white background and black text, thus fully restoring its functionality.
- **HTML Structure:** Overhauled the HTML generation to produce "bulletproof" email code. Replaced the default Unlayer HTML output with a custom generator that creates highly compatible, table-based layouts, fixes image rendering issues in clients like Gmail, and uses responsive-friendly fluid-width containers. This resolves structural inconsistencies and improves cross-client compatibility.
- **Plain Text Not Displaying / Duplication (Invisible Text/Metadata):** Fixed a recurring and persistent bug where the "Plain Text" tab was either displaying extraneous content (like CSS, script, or metadata) or displaying nothing at all, even when visible text was present in the design. Previous regex-based solutions proved insufficient for reliably extracting only the actual content. The latest robust solution replaces the `extractPlainText` function with a `DOMParser` and `TreeWalker`-based approach. This method systematically traverses the parsed HTML body, collecting only `Node.TEXT_NODE` values. This inherently ignores all HTML tags, comments, styles, scripts, and non-visible elements, ensuring that only the user's intended text is accurately extracted, separated by newlines, and displayed without duplication, extraneous code, or missing content.
- **HTML Component Content Not Displaying / Wrapping Issues:** Fixed a critical bug where content from Unlayer's 'HTML' component was not being correctly extracted or was being wrapped by Unlayer's default template structure. The `generateHtmlFromDesign` utility function was overhauled to robustly handle the 'html' component type. It now extracts custom HTML from `content.values.html` or `content.values.content`, and includes logic to "unwrap" full HTML documents by extracting only the content within `<body>` tags and removing `DOCTYPE`, `<html>`, and `<head>` tags. This ensures that custom HTML is seamlessly integrated into the final "bulletproof" email layout without redundant or conflicting structural tags, resulting in accurate multi-tab synchronization.
- **Undo/Redo Functionality:** Fixed a bug where the undo/redo buttons were not working. The issue was that `unlayer.canUndo()` and `unlayer.canRedo()` methods were being called synchronously, returning `undefined`. The fix was to use the asynchronous callback-based approach for these methods, ensuring the component's state is correctly updated with the boolean values indicating whether undo or redo actions are available.
- **Plain Text Generation for Headings:** Fixed a bug where headings in the email design were not appearing in the plain text output. The issue was caused by an inconsistency in the HTML generation process, where the plain text was being generated from a different HTML source than the one displayed in the HTML tab. The fix ensures that the same custom-generated HTML is used for both the HTML preview and the plain text extraction, resulting in accurate and consistent output across all formats.

## Known Issues

- **Linting Error in `EmailEditorWithTabs.jsx`**: There is a persistent linting error (`react-hooks/refs`) in the `EmailEditorWithTabs.jsx` file related to the use of `useMemo` and `debounce` for the auto-save functionality, the Undo/Redo functionality, and the preview features. This error does not affect the application's functionality but is a known issue that could be addressed in the future.

## Building and Running

### Development

To run the application in development mode:

```bash
npm install
npm run dev
```

This will start a development server, and you can view the application in your browser.

### Building for Production

To create a production build of the application:

```bash
npm run build
```

This will create a `dist` directory with the optimized and minified application files.

### Linting

To check the code for any linting errors:

```bash
npm run lint
```

## Development Conventions

### Code Style

The project uses ESLint for code linting. The configuration is in the `eslint.config.js` file. The code style follows standard React and JSX conventions.

### Project Structure

The project is organized into the following directories:

- `src/pages`: Contains top-level components that represent a page in the application. For example, `EditorPage.jsx` is the main page of this application.
- `src/components`: Contains reusable UI components. `EmailEditorWithTabs.jsx`, the core component of this application, is located here.
- `src/utils`: Contains utility functions. `emailUtils.js` is a key file that handles the complex logic of generating email-safe HTML and plain text from the Unlayer design data.
- `src/styles`: Contains global stylesheets. `index.css` is located here.
- `src/assets`: Contains static assets like images and fonts.

The entry point of the application is `src/main.jsx`, which renders the `EditorPage.jsx` component.
